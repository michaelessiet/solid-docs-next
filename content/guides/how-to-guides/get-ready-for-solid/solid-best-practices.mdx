import {Aside} from '~/components/configurable/Aside'

<Title>Solid Best Practices</Title>

In this section we'll be touching on a few best practices to follow when structuring and building your Solid.js apps. 

## Follow proper naming conventions

In Solid it's imperative that you make use of the proper naming conventions not just when creating components but in everything else as well.

Component naming is especially important as if your component it wrongly named the JSX compiler will see it as a normal JSX tag and not a custom component which will lead to runtime errors. Component names should be in PascalCase, starting with a capital letter, and be concise yet descriptive of their purpose. This helps the compiler from differentiating between JSX tags and components.

Here's a quick example of proper component naming conventions in Solid:

```jsx
function MyComponent() {
  return <h1>This is a Solid component</h1>
};

function OtherComponent() {
  return (
    <div>
      <h1>Below is a component</h1>
      <MyComponent/>
    </div>
  )
};
```

Variable and function names should be in camelCase, starting with a lowercase letter, and use descriptive words that accurately reflect their use. Using proper naming conventions helps make code more readable and understandable, making it easier for other developers to collaborate and maintain the codebase. It also helps to avoid naming collisions and improve the code's overall consistency, which is especially important in large codebases. By following proper naming conventions in Solid.js, developers can create high-quality, maintainable code that is easy to understand and modify.

## Avoid prop destructuring

Prop destructuring is not recommended in Solid unlike other Javascript frameworks. In Solid prop destructuring breaks the reactivity of the value being passed as it is being accessed in an unreactive scope. This means that the value being passed will not be updated whenever the proxy value changes.

Here's the proper usage of props in Solid:

```tsx
function MyComponent(props:{randomProp: string}) {
  return <h1>{props.randomProp}</h1>
}
```

Check out the best practice below for more examples and a way to bypass the untracking of your destructured props.

## Pass Accessors instead of values

This continues from the above section about avoiding prop destructuring. We suggest passing [Accessors](#TODO) instead of values in case one or more devs destructure a components props by mistake.

For example this code will not update the `isTrue` memo:

```tsx
import {createSignal, createMemo} from 'solid-js'

function Parent() {
  const [value, setValue] = createSignal(false)  

  return (
    <>
      <button onclick={() => setValue(prev => !prev)}>
        Button is {value().toString()}
      </button>
      <MyComponent value={value()}/>
    </>
  )
}

interface Props {
  value: boolean
}

function MyComponent({value}:Props) {
  const isTrue = createMemo(() => {
    return value ? 'is true' : 'is false'
  })

  return <h1>{isTrue()}</h1>
}
```

In the code above the value returned by the `isTrue` memo will not be updated because the `value` prop is accessed through destructuring instead of being accessed within the `createMemo` callback which is a reactive scope.

However this can be fixed by changing the type of `value` from `boolean` to `Accessor<boolean>` and passing the Accessor.

```tsx
import {createSignal, createMemo, Accessor} from 'solid-js'

function Parent() {
  const [value, setValue] = createSignal(false)  

  return (
    <>
      <button onclick={() => setValue(prev => !prev)}>
        Button is {value().toString()}
      </button>
      <MyComponent value={value}/> // ðŸ‘ˆ the removal of the parenthesis 
    </>
  )
}

interface Props {
  value: Accessor<boolean> // ðŸ‘ˆ the use of Accessor<boolean> instead of boolean
}

function MyComponent({value}:Props) {
  const isTrue = createMemo(() => {
    return value() ? 'is true' : 'is false' // getting the current state of the value prop
  })

  return <h1>{isTrue()}</h1>
}
```

The above code will work as the previous one was expected to work. However, always remember that it is inadvisable to destructure props in Solid

<Aside>
  For more information on Accessors and Solids reactivity system check out this API page on [createSignal](/references/api-reference/basic-reactivity/createSignal), and concept article on [reactivity basics](/references/concepts/reactivity) respectively.
</Aside>

## Signals vs Stores

In Solid Signals and Stores are 2 ways in which you can define reactive values. Signals are good for data types such as booleans, numbers and strings. Stores on the other hand are more suited for nested data types such as objects and arrays. 

Stores are recommended for nested data structures because of the fine grained reactivity that they offer. When a value in a store is updated or deleted only that value is updated and the rest of the object is left untouched. While signals on the other hand do not have the same level of fine grained reactivity when dealing with objects and arrays. That's why it is recommended to use basic data types in Signals and when deaing with complex data types it is recommended to use Stores.

Stores allow for targeted updates, this is possible thanks to the Store's path syntax. Here's what that looks like:

```jsx
const todoId = 0;
const [todos, setTodos] = createStore([]);

const addTodo = (text) => {
  setTodos([...todos, { id: ++todoId, text, completed: false }]);
};

const toggleTodo = (id) => {
  setTodos(
    (todo) => todo.id === id, // we're targeting the specific todo to toggle
    "completed", // we're targeting the value to be modified
    (completed) => !completed // finally toggling the boolean value
  );
};
```

<Aside>
  For more information on Stores and Signals checkout their reference pages: [Stores](/references/api-reference/stores/using-stores) and [Signals](/references/api-reference/basic-reactivity/createsignal) respectively.
</Aside>

## Make use of in-built components

Solid offers a number of in-built components that make it easy to implement lists and conditional rendering in JSX. It's recommended to use these component APIs instead of in-line javascript in your JSX. This ensures that your code stays properly reactive, is easy to read in the template syntax, and doesn't behave unexpectedly or produce unwanted outcomes.

Here's a list of some of the in-built components Solid offers:

- [`<For>`](/references/api-reference/control-flow/for) : This component offers a way to reactively render a list of items. It is similar to using `{array.map(() => <ListComponent/>)}` in JSX, however it is more efficient when handling updates by only updating changed elements.
- [`<Show>`](/references/api-reference/control-flow/show) : This component offers a way to conditionally render part of the view when the `when` condition is truthy. It is similar to the ternary operator `when ? <MyComponent/> : <Fallback/>`, however it's much cleaner and easier to understand.
- [`<Suspense>`](/references/api-reference/control-flow/suspense) : This component offers a way to show a fallback component while the asynchronous resources in its children are loading. Once the asynchronous resources are done the fallback component will be removed and the child component will be displayed.

## Use a Solid.js linter

We recommend using a linter and a plugin specifically configured for Solid when building Solid apps, because it helps in catching those Solid specific errors and implementing the appropriate code style. 

The linter we would recommend using would be ESLint alongside the [Solid ESLint Plugin](https://github.com/solidjs-community/eslint-plugin-solid), this plugin is especially helpful for catching Solid reactivity gotchas and bad practices.

## Use `createUniqueId` when needed

Solid exposes a function that allows you to create a unique ID that can be used as a key for any of your components. In some cases it is recommended to use this when assigning keys to your components instead of using indexes or fetched variables that could possibly have the same value.
